{
  "version": 3,
  "sources": ["../../../src/processReceipt.ts", "../../../utils/utilFuncs.ts", "../../../utils/parseReceiptText.ts"],
  "sourcesContent": ["import { S3Event } from \"aws-lambda\";\nimport { S3Client, GetObjectCommand } from \"@aws-sdk/client-s3\";\nimport { Readable } from \"stream\";\nimport {\n  bufferFromStream,\n  initializeFirestore,\n  initializeGCPvision,\n} from \"../utils/utilFuncs\";\nimport { parseReceiptText } from \"../utils/parseReceiptText\";\n\nconst s3 = new S3Client({ region: \"us-east-1\" });\n\nexport const handler = async (event: S3Event) => {\n  console.log(\"Lambda started, initializing services...\");\n\n  try {\n    const firestore = await initializeFirestore();\n    const visionClient = await initializeGCPvision();\n    console.log(\"Firestore and Vision clients initialized successfully\");\n\n    for (const record of event.Records) {\n      const bucket = record.s3.bucket.name;\n      const key = decodeURIComponent(record.s3.object.key.replace(/\\+/g, \" \"));\n\n      console.log(`Processing file: ${key} from bucket: ${bucket}`);\n\n      const cmd = new GetObjectCommand({ Bucket: bucket, Key: key });\n      const response = await s3.send(cmd);\n\n      if (!response.Body || !(response.Body instanceof Readable)) {\n        console.error(\"Missing or invalid response.Body for key:\", key);\n        continue;\n      }\n\n      console.log(\"Retrieved object from S3\");\n      const imageBuffer = await bufferFromStream(response.Body);\n\n      console.log(\"Calling Vision API for text detection...\");\n      const [visionResult] = await visionClient.textDetection({\n        image: { content: imageBuffer },\n      });\n\n      console.log(\"Vision API response received\");\n      const fullText = visionResult.fullTextAnnotation?.text;\n\n      if (!fullText?.trim()) {\n        console.warn(`No OCR text found for ${key}`);\n        continue;\n      }\n\n      try {\n        console.log(\"Parsing receipt text...\");\n        const parsed = await parseReceiptText(fullText, key);\n\n        const receiptId = key.split(\"/\")[1]?.split(\"_\")[0]; // timestamp from file name\n\n        // Use .doc(receiptId).set() instead of .add()\n        await firestore\n          .collection(\"receiptTransactions\")\n          .doc(receiptId)\n          .set({\n            ...parsed,\n            imageUrl: `https://${bucket}.s3.amazonaws.com/${key}`,\n            createdAt: new Date().toISOString(),\n            receiptId: receiptId,\n          });\n\n        console.log(\"\u2705 Receipt parsed and stored with ID:\", receiptId, parsed);\n      } catch (err) {\n        console.error(\"\u274C Failed to parse or store receipt:\", err);\n        console.error(\"Error details:\", (err as Error).stack);\n      }\n    }\n\n    return {\n      statusCode: 200,\n      body: JSON.stringify({ message: \"Processing completed\" }),\n    };\n  } catch (error) {\n    console.error(\"\u274C Lambda execution error:\", error);\n    console.error(\"Error stack:\", (error as Error).stack);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ error: \"Internal server error\" }),\n    };\n  }\n};\n", "import { Firestore } from \"@google-cloud/firestore\";\nimport {\n  SecretsManagerClient,\n  GetSecretValueCommand,\n} from \"@aws-sdk/client-secrets-manager\";\nimport { Readable } from \"stream\";\nimport { ImageAnnotatorClient } from \"@google-cloud/vision\";\n\nconst secretsManager = new SecretsManagerClient({ region: \"us-east-1\" });\n\nexport interface GcpKey {\n  type: string;\n  project_id: string;\n  private_key_id: string;\n  private_key: string;\n  client_email: string;\n  client_id: string;\n  auth_uri: string;\n  token_uri: string;\n  auth_provider_x509_cert_url: string;\n  client_x509_cert_url: string;\n}\n\ninterface GCPCredentials {\n  gcpKey: GcpKey;\n}\n\nexport const initializeGCPvision = async () => {\n  try {\n    console.log(\"Retrieving vision secret credentials from Secrets Manager...\");\n    const command = new GetSecretValueCommand({\n      SecretId: \"gcp/service-account-key\",\n    });\n    const response = await secretsManager.send(command);\n\n    if (!response.SecretString) {\n      throw new Error(\"No secret string found in Secrets Manager response\");\n    }\n\n    const outerCredentials = JSON.parse(response.SecretString);\n\n    // Parse the nested gcpKey string into an object\n    const gcpKey: GcpKey = JSON.parse(outerCredentials.gcpKey);\n\n    // Validate required fields\n    if (!gcpKey.client_email || !gcpKey.private_key) {\n      throw new Error(\n        \"Invalid service account credentials: missing client_email or private_key\"\n      );\n    }\n\n    const visionClient = new ImageAnnotatorClient({\n      credentials: gcpKey, // Pass the parsed gcpKey object\n    });\n    return visionClient;\n  } catch (error) {\n    console.error(\"Failed to initialize GCP vision:\", error);\n    throw error;\n  }\n};\n\nexport async function initializeFirestore(): Promise<Firestore> {\n  try {\n    console.log(\"Retrieving Firestore credentials from Secrets Manager...\");\n\n    const command = new GetSecretValueCommand({\n      SecretId: \"firestore-key\",\n    });\n\n    const response = await secretsManager.send(command);\n\n    if (!response.SecretString) {\n      throw new Error(\"No secret string found in Secrets Manager response\");\n    }\n\n    console.log(\"BEFORE PARSING\", response.SecretString);\n    const outerCredentials = JSON.parse(response.SecretString);\n    console.log(\"AFTER FIRST PARSING\", outerCredentials);\n\n    // Parse the nested gcpKey string into an object\n    const gcpKey: GcpKey = JSON.parse(outerCredentials.gcpKey);\n    console.log(\"AFTER SECOND PARSING\", gcpKey);\n\n    // Check the parsed gcpKey object\n    if (!gcpKey.client_email || !gcpKey.private_key || !gcpKey.project_id) {\n      console.log(\n        \"Missing fields:\",\n        \"client_email:\",\n        !!gcpKey.client_email,\n        \"private_key:\",\n        !!gcpKey.private_key,\n        \"project_id:\",\n        !!gcpKey.project_id\n      );\n      throw new Error(\"Invalid Firestore credentials: missing required fields\");\n    }\n\n    const firestore = new Firestore({\n      projectId: gcpKey.project_id, // Use the parsed gcpKey\n      credentials: gcpKey, // Pass the parsed gcpKey object\n    });\n\n    console.log(\"Firestore initialized successfully\");\n    return firestore;\n  } catch (error) {\n    console.error(\"Failed to initialize Firestore:\", error);\n    throw error;\n  }\n}\n\nexport async function bufferFromStream(stream: Readable): Promise<Buffer> {\n  return new Promise((resolve, reject) => {\n    const chunks: Buffer[] = [];\n    stream.on(\"data\", (chunk: Buffer) => chunks.push(chunk));\n    stream.on(\"error\", reject);\n    stream.on(\"end\", () => resolve(Buffer.concat(chunks)));\n  });\n}\n", "import {\n  BedrockRuntimeClient,\n  InvokeModelCommand,\n} from \"@aws-sdk/client-bedrock-runtime\";\n\nconst bedrock = new BedrockRuntimeClient({ region: \"us-east-1\" });\n\ninterface ReceiptItem {\n  name: string;\n  price: number;\n  quantity: number;\n}\n\ninterface ParsedReceipt {\n  merchant: string;\n  date: string;\n  total: number;\n  items: ReceiptItem[];\n  tax: number;\n  category: string;\n  rawText?: string;\n  parseError?: string;\n}\n\ninterface BedrockResponse {\n  content: Array<{\n    text: string;\n  }>;\n}\n\nexport async function parseReceiptText(\n  fullText: string,\n  key: string\n): Promise<ParsedReceipt> {\n  try {\n    console.log(\"Parsing receipt text with AWS Bedrock...\");\n\n    const prompt = `\nParse this receipt text and extract the following information in JSON format:\n- merchant: string (store name)\n- date: string (transaction date in YYYY-MM-DD format)\n- total: number (total amount)\n- items: array of objects with {name: string, price: number, quantity: number}\n- tax: number (tax amount if available)\n- category: string (infer category like \"groceries\", \"restaurant\", \"gas\", etc.)\n\nReceipt text:\n${fullText}\n\nReturn only valid JSON, no additional text.\n`;\n\n    const command = new InvokeModelCommand({\n      modelId: \"anthropic.claude-3-haiku-20240307-v1:0\",\n      contentType: \"application/json\",\n      body: JSON.stringify({\n        anthropic_version: \"bedrock-2023-05-31\",\n        max_tokens: 1000,\n        messages: [\n          {\n            role: \"user\",\n            content: prompt,\n          },\n        ],\n      }),\n    });\n\n    const response = await bedrock.send(command);\n\n    if (!response.body) {\n      throw new Error(\"No response body from Bedrock\");\n    }\n\n    const responseBody: BedrockResponse = JSON.parse(\n      new TextDecoder().decode(response.body)\n    );\n\n    // Extract the content from Claude's response\n    const content = responseBody.content[0].text;\n\n    // Parse the JSON response\n    const parsed: ParsedReceipt = JSON.parse(content);\n\n    // Validate the parsed data\n    if (!parsed.merchant || typeof parsed.total !== \"number\") {\n      throw new Error(\"Invalid parsed receipt data structure\");\n    }\n\n    console.log(\"Successfully parsed receipt:\", parsed);\n    return parsed;\n  } catch (error) {\n    console.error(\"Error parsing receipt text:\", error);\n\n    // Fallback parsing if AI fails\n    const fallback: ParsedReceipt = {\n      merchant: \"Unknown\",\n      date: new Date().toISOString().split(\"T\")[0],\n      total: 0,\n      items: [],\n      tax: 0,\n      category: \"unknown\",\n      rawText: fullText,\n      parseError: (error as Error).message,\n    };\n\n    return fallback;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
