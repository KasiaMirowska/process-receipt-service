{
  "version": 3,
  "sources": ["../../../src/processReceipt.ts", "../../../utils/utilFuncs.ts", "../../../utils/parseReceiptText.ts", "../../../utils/textParser.ts"],
  "sourcesContent": ["import { S3Event } from \"aws-lambda\";\nimport { S3Client, GetObjectCommand } from \"@aws-sdk/client-s3\";\nimport { Readable } from \"stream\";\nimport {\n  bufferFromStream,\n  initializeFirestore,\n  initializeGCPvision,\n} from \"../utils/utilFuncs\";\nimport { parseReceiptText } from \"../utils/parseReceiptText\";\n\nconst s3 = new S3Client({ region: \"us-east-1\" });\nconst BUCKET_NAME = \"your-s3-bucket-name\"; // replace this\n\nexport const handler = async (event: S3Event) => {\n  try {\n    const record = event.Records[0];\n    const key = decodeURIComponent(record.s3.object.key.replace(/\\+/g, \" \"));\n    const bucket = record.s3.bucket.name;\n\n    console.log(`\uD83D\uDD14 Lambda triggered by: ${key}`);\n\n    // Ignore non-manifest uploads\n    if (!key.endsWith(\"manifest.json\")) {\n      console.log(\"\u274C Not a manifest file. Skipping...\");\n      return { statusCode: 200, body: \"Not a manifest file. Ignored.\" };\n    }\n\n    // 1. Download the manifest.json\n    const manifestResponse = await s3.send(\n      new GetObjectCommand({ Bucket: bucket, Key: key })\n    );\n\n    if (\n      !manifestResponse.Body ||\n      !(manifestResponse.Body instanceof Readable)\n    ) {\n      throw new Error(\"Failed to read manifest file stream\");\n    }\n\n    const manifestBuffer = await bufferFromStream(manifestResponse.Body);\n    const manifestText = manifestBuffer.toString(\"utf-8\");\n    const manifest = JSON.parse(manifestText) as {\n      receiptId: string;\n      imageKeys: string[];\n    };\n\n    const { receiptId, imageKeys } = manifest;\n\n    console.log(`\uD83D\uDCE6 Manifest for receiptId: ${receiptId}`);\n    console.log(`\uD83D\uDDBC\uFE0F Images to process:`, imageKeys);\n\n    // 2. Init clients\n    const firestore = await initializeFirestore();\n    const visionClient = await initializeGCPvision();\n\n    let combinedText = \"\";\n\n    for (const imageKey of imageKeys) {\n      const cmd = new GetObjectCommand({ Bucket: bucket, Key: imageKey });\n      const response = await s3.send(cmd);\n\n      if (!response.Body || !(response.Body instanceof Readable)) {\n        console.warn(`\u26A0\uFE0F Skipping invalid image file: ${imageKey}`);\n        continue;\n      }\n\n      const imageBuffer = await bufferFromStream(response.Body);\n\n      const [visionResult] = await visionClient.textDetection({\n        image: { content: imageBuffer },\n      });\n\n      const text = visionResult.fullTextAnnotation?.text ?? \"\";\n      console.log(`\u2705 OCR text from ${imageKey} length:`, text.length);\n\n      combinedText += `\\n${text}`;\n    }\n\n    if (!combinedText.trim()) {\n      throw new Error(\"\u274C No OCR text extracted from any image.\");\n    }\n\n    // 3. Parse the combined receipt text\n    const parsed = await parseReceiptText(combinedText, receiptId);\n\n    // 4. Save parsed result to Firestore\n    await firestore\n      .collection(\"receiptTransactions\")\n      .doc(receiptId)\n      .set({\n        ...parsed,\n        receiptId,\n        createdAt: new Date().toISOString(),\n        imageUrls: imageKeys.map(\n          (key) => `https://${bucket}.s3.amazonaws.com/${key}`\n        ),\n      });\n\n    console.log(\"\uD83C\uDF89 Receipt parsed and saved:\", receiptId);\n\n    return {\n      statusCode: 200,\n      body: JSON.stringify({ message: \"Receipt processed\", receiptId }),\n    };\n  } catch (error) {\n    console.error(\"\u274C Error processing manifest-based receipt:\", error);\n    return {\n      statusCode: 500,\n      body: JSON.stringify({\n        error: \"Failed to process receipt\",\n        detail: (error as Error).message,\n      }),\n    };\n  }\n};\n", "import { Firestore } from \"@google-cloud/firestore\";\nimport {\n  SecretsManagerClient,\n  GetSecretValueCommand,\n} from \"@aws-sdk/client-secrets-manager\";\nimport { Readable } from \"stream\";\nimport { ImageAnnotatorClient } from \"@google-cloud/vision\";\n\nconst secretsManager = new SecretsManagerClient({ region: \"us-east-1\" });\n\nexport interface GcpKey {\n  type: string;\n  project_id: string;\n  private_key_id: string;\n  private_key: string;\n  client_email: string;\n  client_id: string;\n  auth_uri: string;\n  token_uri: string;\n  auth_provider_x509_cert_url: string;\n  client_x509_cert_url: string;\n}\n\ninterface GCPCredentials {\n  gcpKey: GcpKey;\n}\n\nexport const initializeGCPvision = async () => {\n  try {\n    console.log(\"Retrieving vision secret credentials from Secrets Manager...\");\n    const command = new GetSecretValueCommand({\n      SecretId: \"gcp/service-account-key\",\n    });\n    const response = await secretsManager.send(command);\n\n    if (!response.SecretString) {\n      throw new Error(\"No secret string found in Secrets Manager response\");\n    }\n\n    const outerCredentials = JSON.parse(response.SecretString);\n\n    // Parse the nested gcpKey string into an object\n    const gcpKey: GcpKey = JSON.parse(outerCredentials.gcpKey);\n\n    // Validate required fields\n    if (!gcpKey.client_email || !gcpKey.private_key) {\n      throw new Error(\n        \"Invalid service account credentials: missing client_email or private_key\"\n      );\n    }\n\n    const visionClient = new ImageAnnotatorClient({\n      credentials: gcpKey, // Pass the parsed gcpKey object\n    });\n    return visionClient;\n  } catch (error) {\n    console.error(\"Failed to initialize GCP vision:\", error);\n    throw error;\n  }\n};\n\nexport async function initializeFirestore(): Promise<Firestore> {\n  try {\n    console.log(\"Retrieving Firestore credentials from Secrets Manager...\");\n\n    const command = new GetSecretValueCommand({\n      SecretId: \"firestore-key\",\n    });\n\n    const response = await secretsManager.send(command);\n\n    if (!response.SecretString) {\n      throw new Error(\"No secret string found in Secrets Manager response\");\n    }\n\n    console.log(\"BEFORE PARSING\", response.SecretString);\n    const outerCredentials = JSON.parse(response.SecretString);\n    console.log(\"AFTER FIRST PARSING\", outerCredentials);\n\n    // Parse the nested gcpKey string into an object\n    const gcpKey: GcpKey = JSON.parse(outerCredentials.gcpKey);\n    console.log(\"AFTER SECOND PARSING\", gcpKey);\n\n    // Check the parsed gcpKey object\n    if (!gcpKey.client_email || !gcpKey.private_key || !gcpKey.project_id) {\n      console.log(\n        \"Missing fields:\",\n        \"client_email:\",\n        !!gcpKey.client_email,\n        \"private_key:\",\n        !!gcpKey.private_key,\n        \"project_id:\",\n        !!gcpKey.project_id\n      );\n      throw new Error(\"Invalid Firestore credentials: missing required fields\");\n    }\n\n    const firestore = new Firestore({\n      projectId: gcpKey.project_id, // Use the parsed gcpKey\n      credentials: gcpKey, // Pass the parsed gcpKey object\n    });\n\n    console.log(\"Firestore initialized successfully\");\n    return firestore;\n  } catch (error) {\n    console.error(\"Failed to initialize Firestore:\", error);\n    throw error;\n  }\n}\n\nexport async function bufferFromStream(stream: Readable): Promise<Buffer> {\n  return new Promise((resolve, reject) => {\n    const chunks: Buffer[] = [];\n    stream.on(\"data\", (chunk: Buffer) => chunks.push(chunk));\n    stream.on(\"error\", reject);\n    stream.on(\"end\", () => resolve(Buffer.concat(chunks)));\n  });\n}\n", "import {\n  BedrockRuntimeClient,\n  InvokeModelCommand,\n} from \"@aws-sdk/client-bedrock-runtime\";\nimport { parseRawText } from \"./textParser\";\nimport { parseArgs } from \"util\";\n\nconst bedrock = new BedrockRuntimeClient({ region: \"us-east-1\" });\n\nexport interface ReceiptItem {\n  name: string;\n  price: number;\n  quantity: number;\n}\n\nexport interface ParsedReceipt {\n  merchant: string;\n  address?: string;\n  date: string;\n  total: number;\n  items: ReceiptItem[];\n  tax: number;\n  category: string;\n  parseError?: string;\n  rawText?: string;\n}\n\nexport interface BedrockResponse {\n  content: Array<{\n    text: string;\n  }>;\n}\n\nexport async function parseReceiptText(\n  fullText: string,\n  key: string\n): Promise<ParsedReceipt> {\n  try {\n    console.log(\"Parsing receipt text with AWS Bedrock...\");\n\n    const prompt = `\nYou are a receipt-parsing assistant.\n\nYour task is to extract structured data from unstructured receipt text.\n\nReturn a **valid JSON object** matching this schema:\n{\n  \"merchant\": string, // e.g. \"Target\", \"Walmart\", \"Chipotle\"\n  \"address\": string,  // if available, full street address\n  \"date\": string,     // format: YYYY-MM-DD\n  \"total\": number,    // final total paid\n  \"tax\": number,      // if present\n  \"items\": [ { \"name\": string, \"price\": number, \"quantity\": number } ],\n  \"category\": string  // one of: groceries, restaurant, gas, clothing, household, electronics, other\n}\n\n### Instructions:\n- The **merchant** is usually in the header \u2014 the first branded line (e.g., \"Target\", \"Trader Joe's\", \"Shell\").\n  - If unclear, guess based on context.\n  - Do NOT return \"Unknown\" \u2014 return the most likely name.\n- Try to extract **address** if it follows the merchant line or is a street format.\n- Ensure all numeric fields are numbers (not strings).\n- If **items** are present, extract their names, prices, and quantity if visible.\n- Guess a **category** based on items or merchant type.\n\n### Receipt Text:\n\\`\\`\\`\n${fullText}\n\\`\\`\\`\n\nReturn only the JSON object. No explanation or extra text.\n`;\n\n    const command = new InvokeModelCommand({\n      modelId: \"anthropic.claude-3-haiku-20240307-v1:0\",\n      contentType: \"application/json\",\n      body: JSON.stringify({\n        anthropic_version: \"bedrock-2023-05-31\",\n        max_tokens: 1000,\n        messages: [\n          {\n            role: \"user\",\n            content: prompt,\n          },\n        ],\n      }),\n    });\n\n    const response = await bedrock.send(command);\n\n    if (!response.body) {\n      throw new Error(\"No response body from Bedrock\");\n    }\n\n    const responseBody: BedrockResponse = JSON.parse(\n      new TextDecoder().decode(response.body)\n    );\n\n    // Extract the content from Claude's response\n    const content = responseBody.content[0].text;\n\n    // Parse the JSON response\n    const parsed: ParsedReceipt = JSON.parse(content);\n    console.log(\"PPPPPPP\", parsed.merchant, parsed);\n    // Validate the parsed data\n    if (!parsed.merchant || typeof parsed.total !== \"number\") {\n      throw new Error(\"Invalid parsed receipt data structure\");\n    }\n    const firstLine = fullText.split(\"\\n\")[0];\n    if (parsed.merchant === \"Unknown\" && /[A-Za-z]{3,}/.test(firstLine)) {\n      parsed.merchant = firstLine.trim();\n    }\n\n    console.log(\"Successfully parsed receipt:\", parsed);\n    return parsed;\n  } catch (error) {\n    console.error(\"Error parsing receipt text:\", error);\n\n    // Fallback parsing if AI fails\n    const fallback: ParsedReceipt = parseRawText(fullText);\n\n    return fallback;\n  }\n}\n", "import type { ParsedReceipt, ReceiptItem } from \"./parseReceiptText\";\n\nexport function parseRawText(rawText: string): ParsedReceipt {\n  try {\n    const lines = rawText\n      .split(\"\\n\")\n      .map((line) => line.trim())\n      .filter(Boolean);\n\n    console.log(\"\uD83D\uDCAC Raw lines to be parsed:\", lines);\n\n    // \u2705 Merchant detection (known keywords)\n    const merchantIndex = lines.findIndex((line) =>\n      /target|walmart|costco|whole\\s?foods|aldi|trader joe's/i.test(line)\n    );\n    const merchant = merchantIndex !== -1 ? lines[merchantIndex] : \"Unknown\";\n\n    // \u2705 Date detection\n    const dateRegex = /\\b(\\d{1,2}[\\/\\-\\.]\\d{1,2}[\\/\\-\\.](\\d{2,4}))\\b/;\n    const dateIndex = lines.findIndex((line) => dateRegex.test(line));\n    const dateMatch =\n      dateIndex !== -1 ? lines[dateIndex].match(dateRegex) : null;\n    const date = dateMatch?.[0] || new Date().toISOString();\n\n    // \u2705 Address = lines between merchant and date\n    let address = \"\";\n    if (merchantIndex !== -1 && dateIndex !== -1 && merchantIndex < dateIndex) {\n      const addressLines = lines\n        .slice(merchantIndex + 1, dateIndex)\n        .filter(\n          (line) =>\n            !dateRegex.test(line) &&\n            !/^\\d{1,2}[\\/\\-\\.]\\d{1,2}[\\/\\-\\.]\\d{2,4}$/.test(line)\n        );\n      address = addressLines.join(\", \");\n    }\n\n    // \u2705 Total detection (same or next line)\n    const totalKeywords = [\"total\", \"amount due\", \"balance due\"];\n    let total = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i].toLowerCase();\n      if (totalKeywords.some((keyword) => line.includes(keyword))) {\n        const currentMatch = lines[i].match(/\\d+[\\.,]?\\d{0,2}/);\n        const nextMatch = lines[i + 1]?.match(/\\d+[\\.,]?\\d{0,2}/);\n        if (currentMatch) {\n          total = parseFloat(currentMatch[0].replace(\",\", \".\"));\n          break;\n        } else if (nextMatch) {\n          total = parseFloat(nextMatch[0].replace(\",\", \".\"));\n          break;\n        }\n      }\n    }\n\n    // \u2705 Tax detection\n    let tax = 0;\n    for (let i = 0; i < lines.length; i++) {\n      if (/tax/i.test(lines[i])) {\n        const currentMatch = lines[i].match(/\\d+[\\.,]?\\d{0,2}/);\n        const nextMatch = lines[i + 1]?.match(/\\d+[\\.,]?\\d{0,2}/);\n        if (currentMatch) {\n          tax = parseFloat(currentMatch[0].replace(\",\", \".\"));\n          break;\n        } else if (nextMatch) {\n          tax = parseFloat(nextMatch[0].replace(\",\", \".\"));\n          break;\n        }\n      }\n    }\n\n    // \u2705 Item parsing after the date\n    const priceRegex = /\\$?\\d+[\\.,]?\\d{0,2}/;\n    const skipKeywords = /total|tax|change|subtotal/i;\n    const linesAfterDate =\n      dateIndex !== -1 ? lines.slice(dateIndex + 1) : lines;\n    const items: ReceiptItem[] = [];\n\n    let skipNextLine = false;\n    for (const line of linesAfterDate) {\n      const lowerLine = line.toLowerCase();\n\n      if (skipNextLine) {\n        skipNextLine = false;\n        continue;\n      }\n\n      if (skipKeywords.test(lowerLine)) {\n        skipNextLine = true;\n        continue;\n      }\n\n      if (\n        priceRegex.test(line) &&\n        !/^\\d{3,}$/.test(line.trim()) && // skip zip codes like 02111\n        !/\\d{5}(-\\d{4})?/.test(line) // skip zip+4 formats\n      ) {\n        const priceMatch = line.match(priceRegex);\n        if (priceMatch) {\n          const match = priceMatch[0];\n          const price = parseFloat(match.replace(\"$\", \"\").replace(\",\", \".\"));\n          const name = line.replace(priceRegex, \"\").trim();\n\n          items.push({\n            name: name || \"Unnamed Item\",\n            price,\n            quantity: 1,\n          });\n        }\n      }\n    }\n\n    // \u2705 Basic category\n    const groceryKeywords = [\n      \"market\",\n      \"grocery\",\n      \"food\",\n      \"store\",\n      \"target\",\n      \"walmart\",\n      \"costco\",\n    ];\n    const category = groceryKeywords.some((word) =>\n      rawText.toLowerCase().includes(word)\n    )\n      ? \"groceries\"\n      : \"Uncategorized\";\n\n    const result: ParsedReceipt = {\n      merchant,\n      address,\n      date,\n      total,\n      items,\n      tax,\n      category,\n    };\n\n    console.log(\"\uD83E\uDDFE Final parsed result:\", result);\n    return result;\n  } catch (err: any) {\n    return {\n      merchant: \"Unknown\",\n      address: \"\",\n      date: new Date().toISOString(),\n      total: 0,\n      items: [],\n      tax: 0,\n      category: \"Uncategorized\",\n      rawText,\n      parseError: err.message || \"Unknown parsing error\",\n    };\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,uBAA2C;AAC3C,oBAAyB;;;ACFzB,uBAA0B;AAC1B,oCAGO;AAEP,oBAAqC;AAErC,IAAM,iBAAiB,IAAI,mDAAqB,EAAE,QAAQ,YAAY,CAAC;AAmBhE,IAAM,sBAAsB,mCAAY;AAC7C,MAAI;AACF,YAAQ,IAAI,8DAA8D;AAC1E,UAAM,UAAU,IAAI,oDAAsB;AAAA,MACxC,UAAU;AAAA,IACZ,CAAC;AACD,UAAM,WAAW,MAAM,eAAe,KAAK,OAAO;AAElD,QAAI,CAAC,SAAS,cAAc;AAC1B,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAEA,UAAM,mBAAmB,KAAK,MAAM,SAAS,YAAY;AAGzD,UAAM,SAAiB,KAAK,MAAM,iBAAiB,MAAM;AAGzD,QAAI,CAAC,OAAO,gBAAgB,CAAC,OAAO,aAAa;AAC/C,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,UAAM,eAAe,IAAI,mCAAqB;AAAA,MAC5C,aAAa;AAAA;AAAA,IACf,CAAC;AACD,WAAO;AAAA,EACT,SAAS,OAAO;AACd,YAAQ,MAAM,oCAAoC,KAAK;AACvD,UAAM;AAAA,EACR;AACF,GAhCmC;AAkCnC,eAAsB,sBAA0C;AAC9D,MAAI;AACF,YAAQ,IAAI,0DAA0D;AAEtE,UAAM,UAAU,IAAI,oDAAsB;AAAA,MACxC,UAAU;AAAA,IACZ,CAAC;AAED,UAAM,WAAW,MAAM,eAAe,KAAK,OAAO;AAElD,QAAI,CAAC,SAAS,cAAc;AAC1B,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAEA,YAAQ,IAAI,kBAAkB,SAAS,YAAY;AACnD,UAAM,mBAAmB,KAAK,MAAM,SAAS,YAAY;AACzD,YAAQ,IAAI,uBAAuB,gBAAgB;AAGnD,UAAM,SAAiB,KAAK,MAAM,iBAAiB,MAAM;AACzD,YAAQ,IAAI,wBAAwB,MAAM;AAG1C,QAAI,CAAC,OAAO,gBAAgB,CAAC,OAAO,eAAe,CAAC,OAAO,YAAY;AACrE,cAAQ;AAAA,QACN;AAAA,QACA;AAAA,QACA,CAAC,CAAC,OAAO;AAAA,QACT;AAAA,QACA,CAAC,CAAC,OAAO;AAAA,QACT;AAAA,QACA,CAAC,CAAC,OAAO;AAAA,MACX;AACA,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAEA,UAAM,YAAY,IAAI,2BAAU;AAAA,MAC9B,WAAW,OAAO;AAAA;AAAA,MAClB,aAAa;AAAA;AAAA,IACf,CAAC;AAED,YAAQ,IAAI,oCAAoC;AAChD,WAAO;AAAA,EACT,SAAS,OAAO;AACd,YAAQ,MAAM,mCAAmC,KAAK;AACtD,UAAM;AAAA,EACR;AACF;AA/CsB;AAiDtB,eAAsB,iBAAiB,QAAmC;AACxE,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAM,SAAmB,CAAC;AAC1B,WAAO,GAAG,QAAQ,CAAC,UAAkB,OAAO,KAAK,KAAK,CAAC;AACvD,WAAO,GAAG,SAAS,MAAM;AACzB,WAAO,GAAG,OAAO,MAAM,QAAQ,OAAO,OAAO,MAAM,CAAC,CAAC;AAAA,EACvD,CAAC;AACH;AAPsB;;;AC9GtB,oCAGO;;;ACDA,SAAS,aAAa,SAAgC;AAC3D,MAAI;AACF,UAAM,QAAQ,QACX,MAAM,IAAI,EACV,IAAI,CAAC,SAAS,KAAK,KAAK,CAAC,EACzB,OAAO,OAAO;AAEjB,YAAQ,IAAI,qCAA8B,KAAK;AAG/C,UAAM,gBAAgB,MAAM;AAAA,MAAU,CAAC,SACrC,yDAAyD,KAAK,IAAI;AAAA,IACpE;AACA,UAAM,WAAW,kBAAkB,KAAK,MAAM,aAAa,IAAI;AAG/D,UAAM,YAAY;AAClB,UAAM,YAAY,MAAM,UAAU,CAAC,SAAS,UAAU,KAAK,IAAI,CAAC;AAChE,UAAM,YACJ,cAAc,KAAK,MAAM,SAAS,EAAE,MAAM,SAAS,IAAI;AACzD,UAAM,OAAO,YAAY,CAAC,MAAK,oBAAI,KAAK,GAAE,YAAY;AAGtD,QAAI,UAAU;AACd,QAAI,kBAAkB,MAAM,cAAc,MAAM,gBAAgB,WAAW;AACzE,YAAM,eAAe,MAClB,MAAM,gBAAgB,GAAG,SAAS,EAClC;AAAA,QACC,CAAC,SACC,CAAC,UAAU,KAAK,IAAI,KACpB,CAAC,0CAA0C,KAAK,IAAI;AAAA,MACxD;AACF,gBAAU,aAAa,KAAK,IAAI;AAAA,IAClC;AAGA,UAAM,gBAAgB,CAAC,SAAS,cAAc,aAAa;AAC3D,QAAI,QAAQ;AACZ,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAM,OAAO,MAAM,CAAC,EAAE,YAAY;AAClC,UAAI,cAAc,KAAK,CAAC,YAAY,KAAK,SAAS,OAAO,CAAC,GAAG;AAC3D,cAAM,eAAe,MAAM,CAAC,EAAE,MAAM,kBAAkB;AACtD,cAAM,YAAY,MAAM,IAAI,CAAC,GAAG,MAAM,kBAAkB;AACxD,YAAI,cAAc;AAChB,kBAAQ,WAAW,aAAa,CAAC,EAAE,QAAQ,KAAK,GAAG,CAAC;AACpD;AAAA,QACF,WAAW,WAAW;AACpB,kBAAQ,WAAW,UAAU,CAAC,EAAE,QAAQ,KAAK,GAAG,CAAC;AACjD;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAGA,QAAI,MAAM;AACV,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAI,OAAO,KAAK,MAAM,CAAC,CAAC,GAAG;AACzB,cAAM,eAAe,MAAM,CAAC,EAAE,MAAM,kBAAkB;AACtD,cAAM,YAAY,MAAM,IAAI,CAAC,GAAG,MAAM,kBAAkB;AACxD,YAAI,cAAc;AAChB,gBAAM,WAAW,aAAa,CAAC,EAAE,QAAQ,KAAK,GAAG,CAAC;AAClD;AAAA,QACF,WAAW,WAAW;AACpB,gBAAM,WAAW,UAAU,CAAC,EAAE,QAAQ,KAAK,GAAG,CAAC;AAC/C;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAGA,UAAM,aAAa;AACnB,UAAM,eAAe;AACrB,UAAM,iBACJ,cAAc,KAAK,MAAM,MAAM,YAAY,CAAC,IAAI;AAClD,UAAM,QAAuB,CAAC;AAE9B,QAAI,eAAe;AACnB,eAAW,QAAQ,gBAAgB;AACjC,YAAM,YAAY,KAAK,YAAY;AAEnC,UAAI,cAAc;AAChB,uBAAe;AACf;AAAA,MACF;AAEA,UAAI,aAAa,KAAK,SAAS,GAAG;AAChC,uBAAe;AACf;AAAA,MACF;AAEA,UACE,WAAW,KAAK,IAAI,KACpB,CAAC,WAAW,KAAK,KAAK,KAAK,CAAC;AAAA,MAC5B,CAAC,iBAAiB,KAAK,IAAI,GAC3B;AACA,cAAM,aAAa,KAAK,MAAM,UAAU;AACxC,YAAI,YAAY;AACd,gBAAM,QAAQ,WAAW,CAAC;AAC1B,gBAAM,QAAQ,WAAW,MAAM,QAAQ,KAAK,EAAE,EAAE,QAAQ,KAAK,GAAG,CAAC;AACjE,gBAAM,OAAO,KAAK,QAAQ,YAAY,EAAE,EAAE,KAAK;AAE/C,gBAAM,KAAK;AAAA,YACT,MAAM,QAAQ;AAAA,YACd;AAAA,YACA,UAAU;AAAA,UACZ,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAGA,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,UAAM,WAAW,gBAAgB;AAAA,MAAK,CAAC,SACrC,QAAQ,YAAY,EAAE,SAAS,IAAI;AAAA,IACrC,IACI,cACA;AAEJ,UAAM,SAAwB;AAAA,MAC5B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,YAAQ,IAAI,kCAA2B,MAAM;AAC7C,WAAO;AAAA,EACT,SAAS,KAAU;AACjB,WAAO;AAAA,MACL,UAAU;AAAA,MACV,SAAS;AAAA,MACT,OAAM,oBAAI,KAAK,GAAE,YAAY;AAAA,MAC7B,OAAO;AAAA,MACP,OAAO,CAAC;AAAA,MACR,KAAK;AAAA,MACL,UAAU;AAAA,MACV;AAAA,MACA,YAAY,IAAI,WAAW;AAAA,IAC7B;AAAA,EACF;AACF;AAvJgB;;;ADKhB,IAAM,UAAU,IAAI,mDAAqB,EAAE,QAAQ,YAAY,CAAC;AA0BhE,eAAsB,iBACpB,UACA,KACwB;AACxB,MAAI;AACF,YAAQ,IAAI,0CAA0C;AAEtD,UAAM,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA2BjB,QAAQ;AAAA;AAAA;AAAA;AAAA;AAMN,UAAM,UAAU,IAAI,iDAAmB;AAAA,MACrC,SAAS;AAAA,MACT,aAAa;AAAA,MACb,MAAM,KAAK,UAAU;AAAA,QACnB,mBAAmB;AAAA,QACnB,YAAY;AAAA,QACZ,UAAU;AAAA,UACR;AAAA,YACE,MAAM;AAAA,YACN,SAAS;AAAA,UACX;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAED,UAAM,WAAW,MAAM,QAAQ,KAAK,OAAO;AAE3C,QAAI,CAAC,SAAS,MAAM;AAClB,YAAM,IAAI,MAAM,+BAA+B;AAAA,IACjD;AAEA,UAAM,eAAgC,KAAK;AAAA,MACzC,IAAI,YAAY,EAAE,OAAO,SAAS,IAAI;AAAA,IACxC;AAGA,UAAM,UAAU,aAAa,QAAQ,CAAC,EAAE;AAGxC,UAAM,SAAwB,KAAK,MAAM,OAAO;AAChD,YAAQ,IAAI,WAAW,OAAO,UAAU,MAAM;AAE9C,QAAI,CAAC,OAAO,YAAY,OAAO,OAAO,UAAU,UAAU;AACxD,YAAM,IAAI,MAAM,uCAAuC;AAAA,IACzD;AACA,UAAM,YAAY,SAAS,MAAM,IAAI,EAAE,CAAC;AACxC,QAAI,OAAO,aAAa,aAAa,eAAe,KAAK,SAAS,GAAG;AACnE,aAAO,WAAW,UAAU,KAAK;AAAA,IACnC;AAEA,YAAQ,IAAI,gCAAgC,MAAM;AAClD,WAAO;AAAA,EACT,SAAS,OAAO;AACd,YAAQ,MAAM,+BAA+B,KAAK;AAGlD,UAAM,WAA0B,aAAa,QAAQ;AAErD,WAAO;AAAA,EACT;AACF;AA1FsB;;;AFvBtB,IAAM,KAAK,IAAI,0BAAS,EAAE,QAAQ,YAAY,CAAC;AAGxC,IAAM,UAAU,8BAAO,UAAmB;AAC/C,MAAI;AACF,UAAM,SAAS,MAAM,QAAQ,CAAC;AAC9B,UAAM,MAAM,mBAAmB,OAAO,GAAG,OAAO,IAAI,QAAQ,OAAO,GAAG,CAAC;AACvE,UAAM,SAAS,OAAO,GAAG,OAAO;AAEhC,YAAQ,IAAI,kCAA2B,GAAG,EAAE;AAG5C,QAAI,CAAC,IAAI,SAAS,eAAe,GAAG;AAClC,cAAQ,IAAI,yCAAoC;AAChD,aAAO,EAAE,YAAY,KAAK,MAAM,gCAAgC;AAAA,IAClE;AAGA,UAAM,mBAAmB,MAAM,GAAG;AAAA,MAChC,IAAI,kCAAiB,EAAE,QAAQ,QAAQ,KAAK,IAAI,CAAC;AAAA,IACnD;AAEA,QACE,CAAC,iBAAiB,QAClB,EAAE,iBAAiB,gBAAgB,yBACnC;AACA,YAAM,IAAI,MAAM,qCAAqC;AAAA,IACvD;AAEA,UAAM,iBAAiB,MAAM,iBAAiB,iBAAiB,IAAI;AACnE,UAAM,eAAe,eAAe,SAAS,OAAO;AACpD,UAAM,WAAW,KAAK,MAAM,YAAY;AAKxC,UAAM,EAAE,WAAW,UAAU,IAAI;AAEjC,YAAQ,IAAI,qCAA8B,SAAS,EAAE;AACrD,YAAQ,IAAI,sCAA0B,SAAS;AAG/C,UAAM,YAAY,MAAM,oBAAoB;AAC5C,UAAM,eAAe,MAAM,oBAAoB;AAE/C,QAAI,eAAe;AAEnB,eAAW,YAAY,WAAW;AAChC,YAAM,MAAM,IAAI,kCAAiB,EAAE,QAAQ,QAAQ,KAAK,SAAS,CAAC;AAClE,YAAM,WAAW,MAAM,GAAG,KAAK,GAAG;AAElC,UAAI,CAAC,SAAS,QAAQ,EAAE,SAAS,gBAAgB,yBAAW;AAC1D,gBAAQ,KAAK,6CAAmC,QAAQ,EAAE;AAC1D;AAAA,MACF;AAEA,YAAM,cAAc,MAAM,iBAAiB,SAAS,IAAI;AAExD,YAAM,CAAC,YAAY,IAAI,MAAM,aAAa,cAAc;AAAA,QACtD,OAAO,EAAE,SAAS,YAAY;AAAA,MAChC,CAAC;AAED,YAAM,OAAO,aAAa,oBAAoB,QAAQ;AACtD,cAAQ,IAAI,wBAAmB,QAAQ,YAAY,KAAK,MAAM;AAE9D,sBAAgB;AAAA,EAAK,IAAI;AAAA,IAC3B;AAEA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,8CAAyC;AAAA,IAC3D;AAGA,UAAM,SAAS,MAAM,iBAAiB,cAAc,SAAS;AAG7D,UAAM,UACH,WAAW,qBAAqB,EAChC,IAAI,SAAS,EACb,IAAI;AAAA,MACH,GAAG;AAAA,MACH;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,WAAW,UAAU;AAAA,QACnB,CAACA,SAAQ,WAAW,MAAM,qBAAqBA,IAAG;AAAA,MACpD;AAAA,IACF,CAAC;AAEH,YAAQ,IAAI,uCAAgC,SAAS;AAErD,WAAO;AAAA,MACL,YAAY;AAAA,MACZ,MAAM,KAAK,UAAU,EAAE,SAAS,qBAAqB,UAAU,CAAC;AAAA,IAClE;AAAA,EACF,SAAS,OAAO;AACd,YAAQ,MAAM,mDAA8C,KAAK;AACjE,WAAO;AAAA,MACL,YAAY;AAAA,MACZ,MAAM,KAAK,UAAU;AAAA,QACnB,OAAO;AAAA,QACP,QAAS,MAAgB;AAAA,MAC3B,CAAC;AAAA,IACH;AAAA,EACF;AACF,GArGuB;",
  "names": ["key"]
}
